---
title: "Visualizing the Collatz Conjecture"
date: 2021-09-03T18:17:02+02:00
draft: true
latex: true
zooms: true
---

# What is the Collatz conjecture ?

Let us choose any positive integer \\(k>0\\), let us then apply the following rules to \\(k\\) repeatedly: 

<!--more-->
{{<longmath>}}
$$
\begin{cases}
k = k/2 &\text{if k is even}\\
k = (k\cdot3) + 1&\text{if k is odd}
\end{cases}
$$
{{</longmath>}}

FOr example, let's choose \\(k=3\\). First, since 3 is odd, we add 1 and triple it, which gives us 10. Then we apply out rule to 10, it's even so we divide it by 2, which gives us 5.  
If we keep applying the rule to each output of the previous step we get the following numbers (when we start at \\(k=3\\)): 

$$
3 \rightarrow 10 \rightarrow 5 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1
$$

Ok we have reached 1, what happens then ? Well, 1 is odd so we triple it and add 1: 4. 4 is even so we divide by 2, which is 2, and finally 2 is even so we divide by 2 which gives us 1. So whenever we reach 1 we will stop applying the rules, since it will just loop forever in the \\(4\rightarrow2\rightarrow1\\) cycle.  

The [collatz conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture) is that whatever the initial value of \\(k\\), as long as its a positive integer, will reach a value of 1 if we apply those rules. It is a conjecture because, even though a lot of mathematicians have tried, nobody has managed to prove it yet. All the numbers up to \\(2^{68}\\) [have been checked](https://doi.org/10.1007%2Fs11227-020-03368-x) (and that is a very large number) but they all end up at 1 eventually.  

# visualizing the conjecture

I'm not the first to tackle this, far from it, I drew inspiration from a lot of sources *([numberphile](), [the coding train]() and wikipedia mainly)*, and if you serach google for visualizations you will find many more, however I still think it's an interesting problem to try and recreate a visualization. 

## Computing the terms

Before visualizing anything, we need data to visualize. What will interest me in this article is the sequence of numbers generated by our set or rules for a chosen value of \\(k\\). To do this we can whip up a very simple piece of python code: 

```python
def get_collatz(k):
    sequence = []

    # if we reach k=1 we know we're done
    while k != 1:

        # We add our value to the sequence
        sequence.append(k)

        # We apply out rules
        if k % 2 == 0:
            k //= 2
        else:
            k = k * 3 + 1

    # This is just to add the final 1 to our sequence
    sequence.append(k)

    return sequence
```
If we apply our function to some positive integers we will get the resulting sequences, for example:

```python
>>> get_collatz(3)
    [3, 10, 5, 16, 8, 4, 2, 1]
>>> get_collatz(22)
    [22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
```

However, for our visualisations we will need a lot of these sequences, and our function is not very efficient. We can do something called [memoization](https://en.wikipedia.org/wiki/Memoization) to make our code more efficient. Memoization simply means that when we reach a point in the sequence that we have already computed we reuse the stored result instead of computing all over again.

```python
# We store our sequences here in a global variable (and we add)
sequences = dict()

def get_collatz_memo(k):
    sequence = []

    while k != 1:

        # We already have the sequence for k
        if k in sequences:
            # We add all the new sequences generated by this run
            for i in range(len(sequence)):
                sequences[sequence[i]] = sequence[i:] + sequences[k]
            # we return the final sequence
            return sequence + sequences[k]

        # We aplpy the rules as before
        sequence.append(k)
        if k % 2 == 0:
            k //= 2
        else:
            k = k * 3 + 1

    sequence.append(k)

    # When we are done we add all the newly calculated sequences
    # to our cache 
    for i in range(len(sequence)):
        # if we reach a sequence that is allreay in the cache we can stop
        if sequence[i] in sequences:
            break
        sequences[sequence[i]] = sequence[i:]

    return sequence

# Now we can actually use memoization
for k in range(1, 101):
    sequences[k] = get_collatz_memo(k)
```

Now when we compute the sequence values it will cache all the subsequences it generates. For 1 and 2 it will simply store the sequences `[1]` and `[2,1]` to the `sequences` cache. Whem we get to 3, things get interseting. Indeed for \\(k=3\\) we have the following sequence: `[3, 10, 5, 16, 8, 4, 2, 1]`, so when we compute `get_collatz_memo(3)` it will store the sequence for \\(k=3\\) in our cache, as well as sequences for \\(k=10, k=5, k=16, \cdots\\)  
So our cache will look like this: 

```python
>>> sequences = dict()
>>> for k in range(1, 4):
        get_collatz_memo(k)
>>>pprint(sequences)

    {1: [1],
     2: [2, 1],
     3: [3, 10, 5, 16, 8, 4, 2, 1],
     4: [4, 2, 1],
     5: [5, 16, 8, 4, 2, 1],
     8: [8, 4, 2, 1],
     10: [10, 5, 16, 8, 4, 2, 1],
     16: [16, 8, 4, 2, 1]}
```

So now when we want `get_collatz_memo(4)` or `get_collatz_memo(5)` it will simply get the one from out cache instead of computing it all from scratch. And this is much more efficient. To see if this is true we will check how much time it takes for each of our functions to compute the first 1000 sequences: 

```python
>>> %%timeit
    sequences = dict()
    for k in range(1, 1001):
        get_collatz(k)

7.98 ms ± 549 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

>>> %%timeit
    sequences = dict()
    for k in range(1, 1001):
        get_collatz_memo(k)

419 µs ± 8.99 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
```

So our memoized function is about an order of magnitude faster than the unmemoized one. 

## Visualization

Finally, with the coding out of the way we can start visualizing the behavior of our sequences. 

### Simple
![maxes](/images/collatz/simple/collatz_maxes.svg)
![points](/images/collatz/simple/collatz_points.svg)

### Graph
![101](/images/collatz/graph/collatz.101.png)
![digraph](/images/collatz/graph/collatz_1000.digraph.png)
![leveled](/images/collatz/graph/collatz_1000.digraph.leveled.png)

### Arc graphs
![10](/images/collatz/arcs/collatz_arc_10.png)
![20](/images/collatz/arcs/collatz_arc_20.png)
![50](/images/collatz/arcs/collatz_arc_50.png)
![100](/images/collatz/arcs/collatz_arc_100.png)
![500](/images/collatz/arcs/collatz_arc_500.png)

### Coral

![simple coral](/images/collatz/coral/collatz_10_000_coral.png)
![coral with hues](/images/collatz/coral/collatz_10_000_hues_coral.png)
![coral with random angles](/images/collatz/coral/collatz_10_000_random_angles_coral.png)
![reds with random angles](/images/collatz/coral/collatz_10_000_random_reds_angles_coral.png)
![reds](/images/collatz/coral/collatz_10_000_reds_coral.png)
![reds transparent](/images/collatz/coral/collatz_10_000_reds_transparent_coral.png)
![transparent 100k](/images/collatz/coral/collatz_100_000_transparent_coral.png)